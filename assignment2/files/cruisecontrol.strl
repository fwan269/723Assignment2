
% Cruise Control design in Esterel

% Cruise control specification using PI control
% Cruise control has two concurrent modules - a UnitControl module that moves the car
% and a RequestResolver module that takes in the user requests and passes a single request to the UnitControl module

% This module controls the operation of the cruise control
% It essentially encodes an FSM
% It also handshakes with Request resolver to read a request

module UnitControl:


% Interface declarations

input CruiseInput: CruiseInput;
output CruiseOutput: CruiseOutput; 
loop
% initak=l cruise state is off
  present currentState
  case OFF do
    if present on then
      cruiseSpeed := ?speed;
      lastCruiseSpeed := cruiseSpeed;
      currentState := ON;
      isGoingOn := true;
    end

  case ON do
    if present off then
      currentState := OFF;

    else if isPressed(?brake) then
      currentState := STDBY;

    else if isPressed(?accel) then
      currentState := DISABLE;

    else
      if present set then
        cruiseSpeed := min(max(?speed, SPEED_MIN), SPEED_MAX);

      else if present quickAccel then
        cruiseSpeed := cruiseSpeed + SPEED_INC;
        if cruiseSpeed > SPEED_MAX then
          currentState := DISABLE;
        end

      else if present quickDecel then
        cruiseSpeed := cruiseSpeed - SPEED_INC;
        if cruiseSpeed < SPEED_MIN then
          currentState := DISABLE;
        end
      end

      % External C function will regulate throttleCmd
      emit throttleCmd(call regulateThrottleC(isGoingOn, cruiseSpeed, ?speed));
      isGoingOn := false;
    end

  case STDBY do
    if present off then
      currentState := OFF;

    else if present resume then
      if isPressed(?accel) or not (?speed > SPEED_MIN and ?speed < SPEED_MAX) then
        currentState := DISABLE;
      else
        currentState := ON;
        cruiseSpeed := lastCruiseSpeed;
      end
    end

  case DISABLE do
    if present off then
      currentState := OFF;

    else if not isPressed(?accel) and (?speed > SPEED_MIN and ?speed < SPEED_MAX) then
      currentState := ON;
      cruiseSpeed := lastCruiseSpeed;
    end
  end present;

  emit cruiseState(currentState);
  emit cruiseSpeed(cruiseSpeed);

  pause;

end loop
end module

% Top level module that runs the two modules in parallel
module CruiseControl:
type CruiseState;
type CruiseInput;
type CruiseOutput;

% interface

input CruiseInput : CruiseInput;
output CruiseOutput : CruiseOutput;

output requestOut : integer;

signal request: integer in
loop
    present request then
        emit requestOut(?request);
    end present;
    pause
end loop
||
run UnitControl[ signal CruiseInput/CruiseInput;
                 signal CruiseOutput/CruiseOutput]
end signal

end module


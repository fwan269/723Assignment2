
% Cruise Control design in Esterel

% Cruise control specification using PI control
% Cruise control has two concurrent modules - a UnitControl module that moves the car
% and a RequestResolver module that takes in the user requests and passes a single request to the UnitControl module

% This module controls the operation of the cruise control
% It essentially encodes an FSM
% It also handshakes with Request resolver to read a request

module UnitControl:
type CruiseState;
% Interface declarations

var currentState:= OFF : CruiseState in;

trap CRUISE_DONE in
loop
  pause;
  trap STEP_TRANSITION in
    if currentState = OFF then
      if present on then
        cruiseSpd := ?speed;
        lastCruiseSpd := cruiseSpd;
        currentState := ON;
        isGoingOn := true;
        exit STEP_TRANSITION;
      end
    end

    if currentState = ON then
      if present off then
        currentState := OFF;
        exit STEP_TRANSITION;

      elsif isPressed(?brake) then
        currentState := STDBY;
        exit STEP_TRANSITION;

      elsif isPressed(?accel) then
        currentState := DISABLE;
        exit STEP_TRANSITION;

      else
        if present set then
          cruiseSpd := min(max(?speed, SPEED_MIN), SPEED_MAX);

        elsif present quickAccel then
          cruiseSpd := cruiseSpd + SPEED_INC;
          if cruiseSpd > SPEED_MAX then
            currentState := DISABLE;
            exit STEP_TRANSITION;
          end

        elsif present quickDecel then
          cruiseSpd := cruiseSpd - SPEED_INC;
          if cruiseSpd < SPEED_MIN then
            currentState := DISABLE;
            exit STEP_TRANSITION;
          end
        end

        emit throttleCmd(call regulateThrottleC(isGoingOn, cruiseSpd, ?speed));
        isGoingOn := false;
        exit STEP_TRANSITION;
      end
    end

    if currentState = STDBY then
      if present off then
        currentState := OFF;
        exit STEP_TRANSITION;

      elsif present resume then
        if isPressed(?accel) or not (?speed > SPEED_MIN and ?speed < SPEED_MAX) then
          currentState := DISABLE;
        else
          currentState := ON;
          cruiseSpd := lastCruiseSpd;
        end
        exit STEP_TRANSITION;
      end
    end

    if currentState = DISABLE then
      if present off then
        currentState := OFF;
        exit STEP_TRANSITION;

      elsif not isPressed(?accel) and (?speed > SPEED_MIN and ?speed < SPEED_MAX) then
        currentState := ON;
        cruiseSpd := lastCruiseSpd;
        exit STEP_TRANSITION;
      end
    end
  end trap

  emit cruiseState(currentState);
  emit cruiseSpeed(cruiseSpd);

end loop
end trap
end module

% Top level module that runs the two modules in parallel
module CruiseControl:
type CruiseState;

% interface

input On;
input Off;
input Resume;
input Set;
input QuickDecel;
input QuickAccel;
input Accel: float;   % Accelerator pedal sensor
input Brake: float;   % Brake pedal sensor
input Speed: float;   % Vehicle speed

output CruiseSpeed: float;
output ThrottleCmd: float;
output CruiseState: CruiseState;

output requestOut : integer;

signal request: integer in
loop
    present request then
        emit requestOut(?request);
    end present;
    pause
end loop
||
run UnitControl[ signal FloorSensor1/FloorSensor;
                 signal MotorDirectionUp1/MotorDirectionUp;
                 signal MotorDirectionDown1/MotorDirectionDown;
                 signal MotorDirectionIdle1/MotorDirectionIdle;
                 signal StoppedAtFloor1/StoppedAtFloor;
                 signal request/request]
end signal

end module

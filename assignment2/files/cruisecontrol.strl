% Authors: Iain J Ross
%          Fang Ping 
%          Tai
% Release date: 24 MAy 2011
% Version-2
% To do in future: environment constraints, exclusion relations and observers for verification
% Also to check code coverage and generate test cases
% Note - SimpleLift.esi scenerio file available for simulation
% Changes: Converted to Esterel V5 syntax -- Simon
  
  
  module UnitControl:
  type CruiseState;
  constant OFF: CruiseState;
  constant ON: CruiseState;
  constant STDBY: CruiseState;
  constant DISABLE: CruiseState;
  constant init = OFF: CruiseState;

  input On;
  input Off;
  input Resume;
  input Set;
  input QuickDecel;
  input QuickAccel;
  input Accel: float;
  input Brake: float;
  input Speed: float;

  output CruiseSpeed: float;
  output ThrottleCmd: float;
  output CruiseState: CruiseState;

  constant SPEED_MIN: float;
  constant SPEED_MAX: float;
  constant SPEED_INC: float;
  constant SPEED_INT: float;

  function regulateThrottle(integer, float, float): float;
  function isPressed(float): boolean;

  var 
    currentState := init: CruiseState,
    cruiseSpd:= SPEED_INT:float,
    lastCruiseSpd:= SPEED_INT: float,
    isGoingOn := 0: integer
  in 
  loop
    pause;
    trap STEP_TRANSITION in

      if currentState = OFF then
       present Accel then
          if isPressed(?Accel) then
            currentState := DISABLE;
            isGoingOn := 0;
            emit CruiseState(currentState);
            exit STEP_TRANSITION;
          end
       end;

       present Brake then
          if isPressed(?Brake) then
            currentState := STDBY;
            emit CruiseState(currentState);
            exit STEP_TRANSITION;
          end
        end;

        present On then
          present Speed then
            cruiseSpd := ?Speed;
            lastCruiseSpd := cruiseSpd;
            currentState := ON;
            isGoingOn := 1;
            emit CruiseState(currentState);
            emit CruiseSpeed(cruiseSpd);
            emit ThrottleCmd(regulateThrottle(isGoingOn, cruiseSpd, ?Speed));
            exit STEP_TRANSITION;
          end
        end
      end;

      if currentState = ON then
        emit CruiseSpeed(cruiseSpd);
        present Off then
          currentState := OFF;
          emit CruiseState(currentState);
          exit STEP_TRANSITION;
        end;

        present Brake then
          if isPressed(?Brake) then
           emit ThrottleCmd(regulateThrottle(isGoingOn, cruiseSpd, ?Speed));
          end
        end;

        present Accel then
          if isPressed(?Accel) then
           emit ThrottleCmd(regulateThrottle(isGoingOn, cruiseSpd, ?Speed));
          end
        end;

        present Set then
          if ?Speed < SPEED_MIN then
          cruiseSpd := SPEED_MIN;
          else if ?Speed > SPEED_MAX then
          cruiseSpd := SPEED_MAX;
          else
          cruiseSpd := ?Speed;
          end
          
        end
        end;

        present QuickAccel then
          cruiseSpd := cruiseSpd + SPEED_INC;
          if cruiseSpd > SPEED_MAX then
            currentState := DISABLE;
            exit STEP_TRANSITION;
          end
        end;

        present QuickDecel then
          cruiseSpd := cruiseSpd - SPEED_INC;
          if cruiseSpd < SPEED_MIN then
            currentState := DISABLE;
            exit STEP_TRANSITION;
          end
        end;

        present Speed then
          emit ThrottleCmd(regulateThrottle(isGoingOn, cruiseSpd, ?Speed));
        end;

        isGoingOn := 0;
        emit CruiseState(currentState);
        exit STEP_TRANSITION;
      end;

      if currentState = STDBY then
        present Off then
          currentState := OFF;
          exit STEP_TRANSITION;
        end;

        present Resume then
          if isPressed(?Accel) or not (?Speed > SPEED_MIN and ?Speed < SPEED_MAX) then
            currentState := DISABLE;
          else
            currentState := ON;
            cruiseSpd := lastCruiseSpd;
          end;
          exit STEP_TRANSITION;
        end
      end;

      if currentState = DISABLE then
         if (?Speed > SPEED_MIN and ?Speed < SPEED_MAX) then
           currentState := ON;
           isGoingOn := 1;
           cruiseSpd := lastCruiseSpd;
           emit ThrottleCmd(regulateThrottle(isGoingOn, cruiseSpd, ?Speed));
           emit CruiseState(currentState);
           emit CruiseSpeed(cruiseSpd);
           exit STEP_TRANSITION;
         else if isPressed(?Accel) then
           currentState := OFF;
           isGoingOn := 0;
           cruiseSpd := lastCruiseSpd;
           emit CruiseState(currentState);
           emit ThrottleCmd(regulateThrottle(0, ?Accel, ?Speed));
           emit CruiseSpeed(cruiseSpd);
           exit STEP_TRANSITION;
          end;
       end;
       isGoingOn := 0;
      end;

      emit CruiseState(currentState);
      emit CruiseSpeed(cruiseSpd);
      emit ThrottleCmd(regulateThrottle(isGoingOn, cruiseSpd, ?Speed));
    end trap;
  end loop;
  end var;
  end module


  % Top level module that runs the two modules in parallel
  module CruiseControl:
  type CruiseState;

  % interface

  input On;
  input Off;
  input Resume;
  input Set;
  input QuickDecel;
  input QuickAccel;
  input Accel: float;   % Accelerator pedal sensor
  input Brake: float;   % Brake pedal sensor
  input Speed: float;   % Vehicle speed

  output CruiseSpeed: float;
  output ThrottleCmd: float;
  output CruiseState: CruiseState;

  run UnitControl[ signal On/On;
                  signal Off/Off;
                  signal Resume/Resume;
                    signal Set/Set;
                    signal QuickDecel/QuickDecel;
                    signal QuickAccel/QuickAccel;
                    signal Accel/Accel;
                    signal Brake/Brake;
                    signal Speed/Speed;
                    signal CruiseSpeed/CruiseSpeed;
                    signal ThrottleCmd/ThrottleCmd;
                    signal CruiseState/CruiseState]

  end module


